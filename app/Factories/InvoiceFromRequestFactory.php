<?php

namespace App\Factories;

use App\Http\Requests\CreateInvoiceRequest;
use App\Models\Student;
use App\Utilities\NumberUtility;
use Illuminate\Support\Collection;

class InvoiceFromRequestFactory extends InvoiceFactory
{
    protected ?CreateInvoiceRequest $request = null;
    protected array $validatedData = [];
    protected Collection $students;

    // Stores the shared attributes among all the
    // invoices generated by the factory:
    // everything except the uuid and student_id, basically
    protected array $invoiceAttributes = [];
    protected array $invoiceItemAttributes = [];
    protected array $invoiceScholarshipAttributes = [];
    protected array $invoicePaymentScheduleAttributes = [];
    protected array $invoicePaymentTermAttributes = [];

    protected int $subtotal = 0;

    public static function make(CreateInvoiceRequest $request = null, Student|Collection $students = null): static
    {
        return (new static)
            ->setStudents($students)
            ->setRequest($request);
    }

    public function setRequest(CreateInvoiceRequest $request = null): static
    {
        $this->request = $request;
        $this->validatedData = $request->validated();
        $this->school = $request->school();

        ray('Validated data', $this->validatedData);

        return $this->setSubtotal()
            ->setInvoiceItemAttributes()
            ->setScholarshipAttributes()
            ->setPaymentScheduleAttributes()
            ->setInvoiceAttributes();
    }

    public function setStudents(Student|Collection $students = null): static
    {
        if ($students instanceof Student) {
            $students = collect([$students]);
        }

        $this->students = $students;

        return $this;
    }

    protected function setSubtotal(): static
    {
        $this->subtotal = array_reduce(
            $this->validatedData['items'],
            fn ($total, $item) => $total + (int) $item['amount_per_unit'] * (int) $item['quantity'], 0
        );

        return $this;
    }

    protected function setInvoiceAttributes(): static
    {
        $this->invoiceAttributes = $this->cleanInvoiceAttributes($this->validatedData);
        $this->invoiceAttributes['batch_id'] = $this->batchId;
        $this->invoiceAttributes['tenant_id'] = $this->school->tenant_id;
        $this->invoiceAttributes['school_id'] = $this->school->id;
        $this->invoiceAttributes['created_at'] = $this->now;
        $this->invoiceAttributes['updated_at'] = $this->now;

        $total = $this->calculateInvoiceTotal();

        $this->invoiceAttributes['amount_due'] = $total;
        $this->invoiceAttributes['remaining_balance'] = $total;
        $this->invoiceAttributes['invoice_date'] = $this->invoiceAttributes['invoice_date']
            ?? now()->format('Y-m-d');

        if ($this->invoiceAttributes['notify']) {
            $this->invoiceAttributes['notified_at'] = null;
            $this->invoiceAttributes['notify_at'] = now()->addMinutes(15)->toIso8601String();
        }

        ray('Invoice attributes', $this->invoiceAttributes);
        return $this;
    }

    protected function setInvoiceItemAttributes(): static
    {
        $this->invoiceItemAttributes = array_reduce(
            $this->validatedData['items'] ?? [],
            function (array $items, array $item) {
                // Cache the total line item
                $item['amount'] = (int) $item['amount_per_unit'] * (int) $item['quantity'];
                $item['batch_id'] = $this->batchId;
                $item['created_at'] = $this->now;
                $item['updated_at'] = $this->now;

                $items[$item['id']] = $this->cleanInvoiceItemAttributes($item);

                return $items;
            }, []
        );

        ray('Invoice item attributes', $this->invoiceItemAttributes);

        return $this;
    }

    protected function setScholarshipAttributes(): static
    {
        $this->invoiceScholarshipAttributes = array_reduce(
            $this->validatedData['scholarships'],
            function (array $items, array $item) {
                // Cache the total line item
                // Need to know which line items this applies to
                $item['percentage'] = NumberUtility::convertPercentageFromUser($item['percentage']);
                $item['calculated_amount'] = $this->calculateScholarshipAmount($item);
                $item['batch_id'] = $this->batchId;
                $item['created_at'] = $this->now;
                $item['updated_at'] = $this->now;

                // This can't be cleaned here because we need
                // to have access to `applies_to` later
                $items[] = $item;

                return $items;
            },
            []
        );

        ray('Scholarship attributes', $this->invoiceScholarshipAttributes);

        return $this;
    }

    protected function setPaymentScheduleAttributes(): static
    {
        $this->invoicePaymentScheduleAttributes = array_map(
            function (array $item) {
                $item['batch_id'] = $this->batchId;
                $item['created_at'] = $this->now;
                $item['updated_at'] = $this->now;
                $item['amount'] = array_reduce(
                    $item['terms'],
                    fn (int $total, array $term) => $total + (int) $term['amount'],
                    0
                );

                // We have to sanitize keys later because
                // we need to keep the reference for terms
                // when building the final insert attributes
                return $item;
            },
            $this->validatedData['payment_schedules']
        );

        return $this;
    }

    protected function calculateScholarshipAmount(array $item): int
    {
        $subtotal = empty($item['applies_to'])
            ? $this->subtotal
            : array_reduce(
                $item['applies_to'],
                fn ($total, $id) => $total + $this->invoiceItemAttributes[$id]['amount'], 0
            );

        $discount = (int) $item['amount'] ?: 0;
        $percentageDiscount = $item['percentage']
            ? (int) round($subtotal * ((float) $item['percentage']))
            : 0;

        if ($discount > 0 && $percentageDiscount > 0) {
            $strategy = $item['resolution_strategy'];
            $resolver = new $strategy();

            return $resolver($discount, $percentageDiscount);
        }

        return $discount > 0
            ? $discount
            : $percentageDiscount;
    }

    protected function calculateInvoiceTotal(): int
    {
        $total = $this->subtotal -
            array_reduce(
                $this->invoiceScholarshipAttributes,
                fn ($total, $item) => $total + $item['calculated_amount'], 0
            );

        return $total > 0
            ? $total
            : 0;
    }

    public function build(): Collection
    {
        $this->students->each(function (Student $student) {
            $invoiceUuid = $this->uuid();

            // Add the invoice attributes
            $this->invoices->push(array_replace(
                ['uuid' => $invoiceUuid, 'student_id' => $student->id],
                $this->invoiceAttributes
            ));

            // Add the items attributes
            // Collection's map preserves the keys
            // which we need to create the scholarships'
            // appliesTo relationship
            $items = collect($this->invoiceItemAttributes)
                ->map(function ($item) use ($invoiceUuid) {
                    $item['uuid'] = $this->uuid();
                    $item['invoice_uuid'] = $invoiceUuid;

                    return $item;
                });

            $this->invoiceItems = $this->invoiceItems->merge($items->values());

            // Add the scholarship attributes
            $this->invoiceScholarships = $this->invoiceScholarships->merge(
                array_map(function ($item) use ($invoiceUuid, $items) {
                    $uuid = $this->uuid();
                    $item['uuid'] = $uuid;
                    $item['invoice_uuid'] = $invoiceUuid;

                    // This may not be a best practice, but using this
                    // loop to create the applies_to mapping
                    $this->itemScholarshipPivot = $this->itemScholarshipPivot->merge(
                        array_map(fn ($apply) => [
                            'invoice_item_uuid' => $items[$apply]['uuid'],
                            'invoice_scholarship_uuid' => $uuid,
                        ], $item['applies_to'] ?? [])
                    );

                    return $this->cleanInvoiceScholarshipAttributes($item);
                }, $this->invoiceScholarshipAttributes)
            );

            // Payment schedules
            if (!empty($this->validatedData['payment_schedules'])) {
                $this->invoicePaymentSchedules = $this->invoicePaymentSchedules->merge(
                    array_map(function (array $item) use ($invoiceUuid) {
                        $scheduleUuid = $this->uuid();
                        $item['uuid'] = $scheduleUuid;
                        $item['invoice_uuid'] = $invoiceUuid;

                        $this->invoicePaymentTerms = $this->invoicePaymentTerms->merge(
                            array_map(function (array $item) use ($invoiceUuid, $scheduleUuid) {
                                $item['uuid'] = $this->uuid();
                                $item['batch_id'] = $this->batchId;
                                $item['invoice_uuid'] = $invoiceUuid;
                                $item['invoice_payment_schedule_uuid'] = $scheduleUuid;
                                $item['created_at'] = $this->now;
                                $item['updated_at'] = $this->now;

                                return $this->cleanPaymentTermAttributes($item);
                            }, $item['terms'])
                        );

                        return $this->cleanPaymentScheduleAttributes($item);
                    }, $this->invoicePaymentScheduleAttributes)
                );
            }
        });

        return $this->store();
    }
}
