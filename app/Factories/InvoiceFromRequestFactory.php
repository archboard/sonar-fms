<?php

namespace App\Factories;

use App\Http\Requests\CreateInvoiceRequest;
use App\Models\Invoice;
use App\Models\Student;
use App\Models\Term;
use App\Utilities\NumberUtility;
use Illuminate\Support\Carbon;
use Illuminate\Support\Collection;

class InvoiceFromRequestFactory extends InvoiceFactory
{
    protected ?CreateInvoiceRequest $request = null;
    protected array $validatedData = [];

    // Stores the shared attributes among all the
    // invoices generated by the factory:
    // everything except the uuid and student_uuid, basically
    protected array $invoiceAttributes = [];
    protected array $invoiceItemAttributes = [];
    protected array $invoiceScholarshipAttributes = [];
    protected array $invoicePaymentScheduleAttributes = [];
    protected array $invoicePaymentTermAttributes = [];
    protected array $invoiceTaxItemAttributes = [];

    protected int $preTaxTotal = 0;
    protected int $subtotal = 0;
    protected int $discountTotal = 0;
    protected ?Term $term = null;
    protected bool $compileTitle = false;

    public static function make(CreateInvoiceRequest $request, string $originalBatchId = null): static
    {
        return (new static)
            ->withOriginalBatchId($originalBatchId)
            ->setRequest($request);
    }

    public function setRequest(CreateInvoiceRequest $request): static
    {
        $this->request = $request;
        $this->validatedData = $request->validated();
        $this->school = $request->school();
        $this->user = $request->user();
        $this->invoiceNumberPrefix = $this->school->getInvoiceNumberPrefix($this->user);
        $this->students = $this->school->students()
            ->whereIn('uuid', $this->validatedData['students'])
            ->get();

        ray('Validated data', $this->validatedData);

        return $this->setInvoiceItemAttributes()
            ->setScholarshipAttributes()
            ->setPaymentScheduleAttributes()
            ->setInvoiceAttributes();
    }

    /**
     * This has to be called after setting invoice items
     * and scholarship items, as it relies on the calculated
     * caches of those functions
     *
     * @return $this
     */
    protected function setInvoiceAttributes(): static
    {
        $this->invoiceAttributes = $this->cleanInvoiceAttributes($this->validatedData);
        $this->invoiceAttributes['batch_id'] = $this->batchId;
        $this->invoiceAttributes['tenant_id'] = $this->school->tenant_id;
        $this->invoiceAttributes['school_id'] = $this->school->id;
        $this->invoiceAttributes['user_uuid'] = $this->user->id;
        // Invoice date is tricky because it isn't a datetime, just a date
        // So we want to store it as the date the user thinks it is, since
        // we don't know the hour offset to convert it from UTC, so make it
        // a static date that doesn't get converted to a weird day based
        // on an arbitrary timezone and don't convert when displaying
        $this->invoiceAttributes['invoice_date'] = ($this->invoiceAttributes['invoice_date'] ?? null)
            ? Carbon::parse($this->invoiceAttributes['invoice_date'])
                ->setTimezone($this->user->timezone)
                ->format('Y-m-d')
            : now($this->user->timezone)->format('Y-m-d');
        $this->invoiceAttributes['created_at'] = $this->now;
        $this->invoiceAttributes['updated_at'] = $this->now;
        // Store the original, un-compiled title
        $this->invoiceAttributes['raw_title'] = $this->invoiceAttributes['title'];

        $this->preTaxTotal = $this->calculateInvoicePreTaxTotal();

        if ($this->invoiceAttributes['notify']) {
            $this->invoiceAttributes['notified_at'] = null;
            $this->invoiceAttributes['notify_at'] = $this->notifyAt;
        }

        $this->term = $this->invoiceAttributes['term_id']
            ? Term::find($this->invoiceAttributes['term_id'])
            : null;
        $this->compileTitle = str_contains($this->invoiceAttributes['title'], '{');

        $this->setInvoiceTotalsAttributes();

        ray('Invoice attributes', $this->invoiceAttributes);
        return $this;
    }

    protected function setInvoiceItemAttributes(): static
    {
        $this->invoiceItemAttributes = array_reduce(
            $this->validatedData['items'] ?? [],
            function (array $items, array $item) {
                // Cache the total line item
                $amount = (int) $item['amount_per_unit'] * (int) $item['quantity'];
                $item['amount'] = $amount;
                $item['batch_id'] = $this->batchId;
                $item['created_at'] = $this->now;
                $item['updated_at'] = $this->now;

                $items[$item['id']] = $this->cleanInvoiceItemAttributes($item);

                $this->subtotal += $amount;

                return $items;
            }, []
        );

        ray('Invoice item attributes', $this->invoiceItemAttributes);

        return $this;
    }

    protected function setScholarshipAttributes(): static
    {
        $this->invoiceScholarshipAttributes = array_reduce(
            $this->validatedData['scholarships'],
            function (array $items, array $item) {
                // Cache the total line item
                // Need to know which line items this applies to
                $item['percentage'] = NumberUtility::convertPercentageFromUser($item['percentage']);
                $item['calculated_amount'] = $this->calculateScholarshipAmount($item);
                $item['batch_id'] = $this->batchId;
                $item['created_at'] = $this->now;
                $item['updated_at'] = $this->now;

                // This can't be cleaned here because we need
                // to have access to `applies_to` later
                $items[] = $item;

                $this->discountTotal += $item['calculated_amount'];

                return $items;
            }, []);

        ray('Scholarship attributes', $this->invoiceScholarshipAttributes);

        return $this;
    }

    protected function setPaymentScheduleAttributes(): static
    {
        $this->invoicePaymentScheduleAttributes = array_map(
            function (array $item) {
                $item['batch_id'] = $this->batchId;
                $item['created_at'] = $this->now;
                $item['updated_at'] = $this->now;
                $item['amount'] = array_reduce(
                    $item['terms'],
                    fn (int $total, array $term) => $total + (int) $term['amount'],
                    0
                );

                // We have to sanitize keys later because
                // we need to keep the reference for terms
                // when building the final insert attributes
                return $item;
            },
            $this->validatedData['payment_schedules']
        );

        return $this;
    }

    protected function calculateScholarshipAmount(array $scholarshipItem, array $itemIds = []): int
    {
        $subtotal = empty($itemIds)
            ? $this->subtotal
            : array_reduce(
                $itemIds,
                fn ($total, $id) => $total + $this->invoiceItemAttributes[$id]['amount'], 0
            );

        if (!empty($scholarshipItem['applies_to'])) {
            $subtotal = array_reduce(
                $scholarshipItem['applies_to'],
                function ($total, $id) use ($itemIds) {
                    if (
                        empty($itemIds) ||
                        in_array($id, $itemIds)
                    ) {
                        return $total + $this->invoiceItemAttributes[$id]['amount'];
                    }

                    return $total;
                },
                0
            );

            // If the subtotal at this point is 0,
            // this means there are no tax items
            // that overlap with the scholarship's `applies_to`
            if ($subtotal === 0) {
                return 0;
            }
        }

        $discount = (int) $scholarshipItem['amount'] ?: 0;

        // If we're only dealing with a set of items, we need to calculate
        // the relative discount from the static amount
        if ($discount > 0 && !empty($itemIds)) {
            $discount = array_reduce(
                $itemIds,
                function ($total, $id) use ($discount) {
                    return $total +
                        ($this->subtotal > 0 ? $this->invoiceItemAttributes[$id]['amount'] / $this->subtotal : 0) *
                        $discount;
                },
                0,
            );
        }

        $percent = NumberUtility::convertPercentageFromUser($scholarshipItem['percentage']);
        $percentageDiscount = $scholarshipItem['percentage']
            ? round($subtotal * $percent)
            : 0;

        if ($discount > 0 && $percentageDiscount > 0) {
            $strategy = $scholarshipItem['resolution_strategy'];
            $resolver = new $strategy();

            return $resolver($discount, $percentageDiscount);
        }

        return $discount > 0
            ? $discount
            : $percentageDiscount;
    }

    protected function calculateInvoicePreTaxTotal(): int
    {
        $total = $this->subtotal - $this->discountTotal;

        return $total > 0
            ? $total
            : 0;
    }

    protected function setInvoiceTotalsAttributes(): static
    {
        $this->setTaxAttributes();

        $this->invoiceAttributes['subtotal'] = $this->subtotal;
        $this->invoiceAttributes['discount_total'] = $this->discountTotal > $this->subtotal
            ? $this->subtotal
            : $this->discountTotal;
        $this->invoiceAttributes['pre_tax_subtotal'] = $this->preTaxTotal;

        $this->setTaxDueAttribute();

        $totalDue = $this->preTaxTotal + $this->invoiceAttributes['tax_due'];
        $this->invoiceAttributes['amount_due'] = $totalDue;
        $this->invoiceAttributes['remaining_balance'] = $totalDue;
        $this->invoiceAttributes['relative_tax_rate'] = $totalDue > 0
            ? round($this->invoiceAttributes['tax_due'] / $totalDue, 8)
            : 0;

        return $this;
    }

    protected function setTaxAttributes(): static
    {
        if (
            !$this->school->collect_tax ||
            !$this->invoiceAttributes['apply_tax']
        ) {
            $this->invoiceAttributes['tax_rate'] = 0;
            $this->invoiceAttributes['tax_label'] = null;

            return $this;
        }

        if ($this->invoiceAttributes['use_school_tax_defaults']) {
            $this->invoiceAttributes['tax_rate'] = $this->school->tax_rate;
            $this->invoiceAttributes['tax_label'] = $this->school->tax_label;

            return $this;
        }

        // Convert the percentage value from the user,
        // since they will enter as an integer
        $this->invoiceAttributes['tax_rate'] = NumberUtility::convertPercentageFromUser(
            $this->invoiceAttributes['tax_rate']
        );

        return $this;
    }

    protected function setTaxDueAttribute(): static
    {
        // The simple case of applying to all items,
        // or if there are not more than 1 tax items
        // then we're applying the tax to all the items
        if (
            ($this->invoiceAttributes['apply_tax_to_all_items'] ?? true) ||
            count($this->validatedData['tax_items']) < 2
        ) {
            $this->invoiceAttributes['tax_due'] = round($this->preTaxTotal * $this->invoiceAttributes['tax_rate']);

            return $this;
        }

        $this->setTaxItemAttributes();

        // We can determine the tax due after setting the attributes
        $this->invoiceAttributes['tax_due'] = array_reduce(
            $this->invoiceTaxItemAttributes,
            fn ($total, $item) => $total + $item['amount'],
            0,
        );

        return $this;
    }

    protected function setTaxItemAttributes()
    {
        $this->invoiceTaxItemAttributes = array_map(
            function (array $taxItem) {
                $subtotal = $this->invoiceItemAttributes[$taxItem['item_id']]['amount'];
                // This runs through each scholarship and determines
                // if the scholarship applies to the tax's invoice item
                // Start with the subtotal and subtract the discounts
                $pretax = array_reduce(
                    $this->validatedData['scholarships'],
                    function ($total, $scholarshipItem) use ($taxItem) {
                        $discount = $this->calculateScholarshipAmount($scholarshipItem, [$taxItem['item_id']]);
                        ray('item discount', $discount);

                        return $total - $discount;
                    },
                    $subtotal,
                );

                $pretax = $pretax < 0 ? 0 : $pretax;
                $taxRate = NumberUtility::convertPercentageFromUser($taxItem['tax_rate']);

                return [
                    'item_id' => $taxItem['item_id'],
                    'amount' => round($pretax * $taxRate),
                    'tax_rate' => $taxRate,
                    'created_at' => $this->now,
                    'updated_at' => $this->now,
                ];
            },
            array_filter(
                $this->validatedData['tax_items'] ?? [],
                fn ($taxItem) => $taxItem['selected']
            ),
        );
    }

    public function build(): Collection
    {
        $this->students->each(function (Student $student) {
            $invoiceUuid = $this->studentInvoiceMap
                ->get($student->uuid, $this->uuid());
            $invoiceNumber = $this->invoiceNumberMap
                ->get($student->uuid, Invoice::generateInvoiceNumber($this->school->id, $this->invoiceNumberPrefix));
            $title = $this->compileTitle
                ? $this->school->compileTemplate($this->invoiceAttributes['title'], student: $student, term: $this->term)
                : $this->invoiceAttributes['title'];

            // Add the invoice attributes
            $this->invoices->push(array_replace(
                $this->invoiceAttributes,
                [
                    'uuid' => $invoiceUuid,
                    'student_uuid' => $student->uuid,
                    'published_at' => $this->asDraft ? null : $this->now,
                    'invoice_number' => $invoiceNumber,
                    'title' => $title,
                    'grade_level' => $student->grade_level + ($this->invoiceAttributes['grade_level_adjustment'] ?? 0),
                ]
            ));

            // Add the items attributes
            // Collection's map preserves the keys
            // which we need to create the scholarships'
            // appliesTo relationship
            $items = collect($this->invoiceItemAttributes)
                ->map(function ($item) use ($invoiceUuid) {
                    $item['uuid'] = $this->uuid();
                    $item['invoice_uuid'] = $invoiceUuid;

                    return $item;
                });

            $this->invoiceItems = $this->invoiceItems->merge($items->values());

            // Add the scholarship attributes
            $this->invoiceScholarships = $this->invoiceScholarships->merge(
                array_map(function ($item) use ($invoiceUuid, $items) {
                    $uuid = $this->uuid();
                    $item['uuid'] = $uuid;
                    $item['invoice_uuid'] = $invoiceUuid;

                    // This may not be a best practice, but using this
                    // loop to create the applies_to mapping
                    $this->itemScholarshipPivot = $this->itemScholarshipPivot->merge(
                        array_map(fn ($apply) => [
                            'invoice_item_uuid' => $items[$apply]['uuid'],
                            'invoice_scholarship_uuid' => $uuid,
                        ], $item['applies_to'] ?? [])
                    );

                    return $this->cleanInvoiceScholarshipAttributes($item);
                }, $this->invoiceScholarshipAttributes)
            );

            // Payment schedules
            $this->invoicePaymentSchedules = $this->invoicePaymentSchedules->merge(
                array_map(
                    function (array $item) use ($invoiceUuid) {
                        $scheduleUuid = $this->uuid();
                        $item['uuid'] = $scheduleUuid;
                        $item['invoice_uuid'] = $invoiceUuid;

                        $this->invoicePaymentTerms = $this->invoicePaymentTerms->merge(
                            array_map(function (array $item) use ($invoiceUuid, $scheduleUuid) {
                                $item['uuid'] = $this->uuid();
                                $item['batch_id'] = $this->batchId;
                                $item['invoice_uuid'] = $invoiceUuid;
                                $item['invoice_payment_schedule_uuid'] = $scheduleUuid;
                                $item['amount_due'] = $item['amount'];
                                $item['remaining_balance'] = $item['amount'];
                                $item['created_at'] = $this->now;
                                $item['updated_at'] = $this->now;

                                return $this->cleanPaymentTermAttributes($item);
                            }, $item['terms'])
                        );

                        return $this->cleanPaymentScheduleAttributes($item);
                    },
                    $this->invoicePaymentScheduleAttributes
                )
            );

            // Invoice tax items
            $this->invoiceTaxItems = $this->invoiceTaxItems->merge(
                array_map(
                    fn ($taxItem) => [
                        'uuid' => $this->uuid(),
                        'invoice_uuid' => $invoiceUuid,
                        'invoice_item_uuid' => $items[$taxItem['item_id']]['uuid'],
                        'amount' => $taxItem['amount'],
                        'tax_rate' => $taxItem['tax_rate'],
                    ],
                    $this->invoiceTaxItemAttributes,
                )
            );
        });

        return $this->store();
    }
}
